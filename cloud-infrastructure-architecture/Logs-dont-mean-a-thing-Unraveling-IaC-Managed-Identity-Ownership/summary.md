# Logs don't mean a thing: Unraveling IaC-Managed Identity Ownership

**Video Link**: [Watch on YouTube](https://www.youtube.com/watch?v=DCZtNldY5iI)

- **Author**: Dan Abramov & Elia Livna
- **Talk Type**: Cloud Infrastructure & Architecture

## Summary

Dan Abramov and Elia Livna from Token Security present a critical challenge in cloud security: determining who owns machine identities created through Infrastructure as Code (IaC). 

When Terraform or CloudFormation creates a service account, traditional audit logs only show "Terraform" as the creator—not the human responsible. The speakers evaluate three approaches to solve this problem: execution-based tagging, log correlation, and LLM-powered code analysis. Their log-based solution correlates CloudTrail events with CI/CD pipeline logs to trace identity creation back to specific commits and authors, providing automated ownership discovery without modifying customer environments.

## Key Points

- **The ownership problem**: When IaC creates identities, logs show Terraform/CloudFormation as creator, not the human owner
- **Machine identities are decentralized**: Unlike human identities managed in a single IDP, machine identities are scattered across platforms
- **Dynamic code complicates tracking**: Identity names use variables, templates, modules spread across multiple files
- **Three approaches tested**:
  1. **Execution-based tagging**: Clone code, add file tags, run Terraform plan
  2. **Log correlation**: Match CloudTrail events to CI/CD logs to find commit authors
  3. **LLM code analysis**: Parse state files and code to trace identity creation
- **Winner: Log-based approach** - Works across all IaC tools, CI/CD platforms, and CSPs
- **Main limitation**: Depends on log retention periods (both CSP and CI/CD)
- **Real example**: Role creation at 10:45 → Find pipeline run at 10:45 → Trace to PR author
- **Finance partnership opportunity**: Leverage existing tagging requirements for cost attribution

## Technical Details

**The IaC Identity Creation Challenge:**
- Simple scenario: `aws_iam_role "production_user_postgres"` - easy to trace
- Reality: Identity names built from:
  - Module files defining role templates
  - Environment-specific variable files  
  - Main project Terraform files
  - CI/CD configuration YAML variables
  - Result: 4+ files contribute to one identity creation

**Approach 1: Execution-Based Tagging**
```hcl
# Clone original code and add tags
resource "aws_iam_role" "example" {
  name = var.role_name
  tags = {
    "iac_file_module" = "modules/iam/main.tf"
    "iac_file_env" = "environments/prod.tf"
    "iac_file_main" = "main.tf"
    "iac_file_cicd" = ".github/workflows/deploy.yml"
  }
}
```
- Run `terraform plan` to see which files create which identities
- **Pros**: Direct file-to-identity mapping
- **Cons**: Requires executing in customer environment

**Approach 2: Log Correlation (Winning Solution)**
1. Find creation event in CloudTrail:
   ```json
   {
     "eventTime": "2024-01-15T10:45:00Z",
     "eventName": "CreateRole",
     "requestParameters": {
       "roleName": "sales-app-role"
     },
     "userIdentity": {
       "principalId": "terraform-service-account"
     }
   }
   ```

2. Search CI/CD logs for matching timestamp and identity name:
   ```
   [10:45:00] Creating aws_iam_role.sales_app_role...
   [10:45:01] Creation complete: arn:aws:iam::123456789012:role/sales-app-role
   ```

3. Use CI/CD API to find triggering commit:
   ```python
   # Pseudocode
   pipeline = github.get_pipeline_run(timestamp="2024-01-15T10:45:00")
   commit = pipeline.triggering_commit
   author = commit.author  # "devops-snake9"
   ```

**Approach 3: LLM-Powered Analysis**
- Feed LLM with:
  - All Terraform files
  - CI/CD configurations  
  - State files listing created identities
  - Variable definitions and templates
- Ask LLM to trace variable resolution and file dependencies
- **Result**: Too many hallucinations, insufficient accuracy

**Implementation Considerations:**
- **Log retention requirements**:
  - CloudTrail: Default 90 days (extendable)
  - GitHub Actions: 90 days
  - GitLab CI: 30 days default
  - Jenkins: Varies by configuration
- **API timestamps**: Can use resource creation timestamps even without logs
- **Proactive indexing**: Build identity→commit mapping as events occur

**For Organizations:**
- Implement tagging standards in IaC templates
- Ensure adequate log retention (recommend 1+ year)
- Consider fail-on-missing-owner-tag policies in CI/CD
- Partner with finance teams who already require tagging

## Full Transcript

Good morning and uh welcome back to our next talk. Uh before we begin uh we'd as always like to thank all of our sponsors who make this whole event possible and particularly we'd like to thank our silver sponsor cyig. Uh go ahead and uh chat with them out in the hallway and just let them know how much you appreciate their support of this event. So our next talk is logs don't mean a thing unraveling IA managed identity ownership with Dan Abramov and Elia Livna. So please welcome them to the stage. A notice from your sock team saying that 80s sync admin was compromised and you need to do something. You need to suspend it. You need to rotate it. You don't know and you just need to find who is the owner for this service account. So who you going to call? In today's talk, we will talk about identity ownership and why it's important, how to determine it, and how I complicates finding it. We'll talk about IC deployment, the different components in this deployment. And we'll deep dive into it understanding how we tackle the challenge of unraveling identity ownership for IEC created identities. And we thought what would be a better way to have this talk more than if we're in America we'll talk in a game show format we like to call who is the owner. So let's break it down. First let you uh know what your host for this talk. My name is Dana Bramov. The one but not only uh it appears appears to be. I'm not a React developer. I am a a security researcher at token security. I'm a musician and I play a piano and saxophone and I like about any kind of sport. And and I'm Elia. I'm also security researcher at Token. Uh and I'm also a dad. I love to cycle. I like rocks way more than average. Uh and if you look me up on YouTube, you'll mainly find Taylor Swift piano covers. All right, so let's talk about ownership. What does it mean to be an owner of an identity? So the owner of an identity is actually the human responsible for managing that identity whether it has to do with day-to-day management such as key rotation or changing permissions uh or dealing with incidents when they happen just like the scenario from the beginning. Now small disclaimer um human identities tend to be much more centrally managed um in a single IDP by one or two teams uh many times from the HRIS system but machine identities or non-human identities tend to be much more decentralized scattered across various platforms with owners all across the organization uh and these identities tend to be managed much more in infrastructure as code systems so this talk is going to focus mainly on those type of machine or non-human identities. Now, how do we determine ownership in the first place? So, with regular identities or non-infrastructures code-managed identities, uh well, the most straightforward thing we can do is look at the activity locks, if we find the creation event or other management events being done on that identity, then we can see who the actor was and determine the owners. So if we take a look at these examples from cloud trail, we can see that Michael and Andrew were the creators or and updators of this specific role. So in this case, it's very simple to determine that Michael and Andrew are are the owners are the owners are the owners of this identity. Sorry. Now, okay, we solved the problem, right? We found the owners. But with infrastructure as code, it becomes more complicated because what we can see here, for example, is that Terraform is who created this role. And Terraform isn't someone I can just pick up and call and ask for help in case of need. So, first Dan will back up a bit and explain a bit about infrastructure as code. Okay. Okay, so infrastructure is code. You may know it as Terraform. You may know it as Palumi or uh cloud formation for AWS. It's a declarative language to create resources in your uh cloud environments. You can create anything from networks from VMs and all the way to identities. And the problem as Ali said is when creating non-human identities when the creator is a non-human identity, it's much harder to determine who is the owner and who is your PC in case of crisis. So if you look at this this diagram here, you can see that a simple IC deployment makes it harder for us to find the owner because uh originally we have a single line connecting between the person who is the owner for an identity and the new identity being created. But now you have a multi-stage uh process of understanding who is the person that edits the code, the declaring file that creates the identity. So it makes it a little bit more complicated. And again question has to be asked is who is the owner? Well one thing we know is that code is an integral part of the identity being created by IA. So if we can find the person who writes this code it's easier for us to understand this uh problem because it's a solved problem right you know who is a person who edits code. You have it in every git platform. Now we need to know which pieces of code are relevant to the creation of new identities. And this is the hard part. Now we did it first like pretty straightforward way because we thought well it should be kind of easy because the name of the created identity must be explicitly written in the code somehow. So if we had it like this it would be pretty simple. If we have a production usist one pro posgress role then we just look at this identity. We find this name in the code and we know that each person that edits it is one of the owners for this identity. But the sad reality is that it's not that simple because it's code. It's dynamic. It has function templates. It uses modules and creation of identities is being uh scattered around different files and different variables. So it's not a very easy job to do. If we can look at this example, we can see that if we have this data inester production IM role, it's being created by a few different files. The first one would be the module file that creates roles. The second one would be something that is relevant to the environment that you're creating. If you're creating a production environment, staging environ dev environment, you want different things to use the same module to avoid code duplication. And you have the main produ uh the main uh project terraform file that is declaring this identity. And besides the code that you have, you also have the CI/CD configuration files that also have variables in this in a YAML file. So you have four different files relevant to the creation of one identity and it makes it much more complicated to find who are the owners that added all these kind of files. So how will we do it? First, we are a game show and we have lifelines. So, we figured out we should go to the most straightforward things we can do. So, we have IC logs that uh sadly weren't sufficient for our use case because they were mainly functional and didn't really follow the process of which files creating a new identity or resource. We looked at open- source tools that weren't suitable for our specific use case. And we thought maybe we can write IA parser ourselves and we can parse Terraform code and understand and follow the process of identity creation. But none of them were good enough for us because uh they weren't sufficient enough and we thought that we don't want to write uh parser for each kind of IA language. It would take too much time for us and we didn't have that time. So in order to deeper dive and understand how we uh ch uh face this challenge, Elia will walk you through how average IC deployment looks like. So let's walk through the different components and artifacts throughout the deployment process of an infrastructures code managed identity. So on the left side it starts with a commit a commit to the IA repository changing or creating a new identity. uh that commit or a PR it contains that is merged uh then triggers a pipeline run that runs the IC tool which then would read the code understand what changes need to be made and go to the CSP to AWS for example and do those changes and often I see platforms also utilize intermediate or state files along the way to kind of save the desired state and also the previously uh held state in the cloud. So if you look at all the different artifacts we have at our disposal to try and deal with this challenge, we have the code itself, the IC code in the repository, we have the commit history for that repository. We have the CI/CD configurations and the CI/CD logs. We have the state files and we have the CSP data itself, the logs and the API data there. So we're now going to go through our three main contestants then which we tried to use to solve this challenge. Uh and as you'll soon see, no single artifact here was enough to solve the problem. We had to use a combination of them. Okay. So, welcome again to who is the owner? And we're going to showcase the three contestants to find the best way to find owners for IA created identities. And your first contestant would be the execution exe executionbased approach using tags. So, we figured that we wanted to create an IA uh parser and we also didn't have sufficient enough logging. So we thought what if we can make some kind of our own logging. If we take the original code and clone it create a replica with we add it the IA and we add tags. Tags is a feature that uh allows you to add some kind of strings to any resource you create in the cloud. So if we do that and we add those tags and which tag each tag will contain the name of the file then if we execute the terraform or create a plan output we can see for each identity which are the files that are relevant to the creation of it. Then we can trace it back to who are the actual owners and editors of those files. If we look at the same example we've seen before we have those all of those files that are relevant to the creation of this identity. And if we add tags, eventually the output we're going to have is the same identity being created and all of the files that are relevant to its creation and their actual uh purpose. So you have the module file that is relevant, the environment file all the way up to the CI/CD configuration file. So it's a pretty cool way to do it, but it has a lot of drawbacks. It doesn't require logs, so it's pretty cool. But, uh, it actually needs to execute Terraform. You need to execute the IA engine. And it's not a very easy job to do, especially if you're working on a target environment that you don't fully control cuz you don't want to uh engage with this environment and interact with it because it's not your environment. So, it's a pretty big disadvantage and we'll figure out in the way which one we selected eventually. So let's go to our second contestant. So the second contestant is our log based approach. In it, we thought to ourselves, maybe we can cheat. Maybe we can completely sidestep the process of needing to look at the code itself. Maybe we can just use the logs as an indicator of what happened and through that find who the owners are. So we discovered through our research that when IC tools run they print in their output logs the names of the identities that they change or create which makes a lot of sense. So what we would do in this method is we would take a management event that we see in the cloud for example a role being created and then we would go back and find the specific pipeline run that caused that event to happen and we would see what commit would trigger that specific pipeline and we can find directly the author of that commit. So if we look at a real example using AWS and Terraform, we have here a role creation event from cloudt trail in which we can see that a certain time Terraform created the sales app role and programmatically using GitHub API. We go back and look through all the different pipeline runs that happened in the minutes and hours surrounding that specific time looking throughout the different logs of those pipelines searching for the name of this identity. And indeed we can find one. We can find the specific sales app role being created at the exact same time stamp as the creation event appears in cloud trail. And using the API, we can also then tell that this pipeline Terraform plan and apply ran as a trigger from this pull request and bam, we have the author of this pull request. The actual timeline is reversed. First this person created the pull request which triggered this pipeline to run which ran the IA tool which eventually created the event the role in AWS. So correlating and piecing all of this together we can now automatically determine that this DevOps snake 9 is the owner of the sales app role. So this method is strong. It has several advantages. Mainly it's IC agnostic. It works on all IC platforms because it doesn't even need to look at the code at all and it's also CI/CD agnostic. It works across the different products and also CSP and target platform agnostic. However, its main drawback is that as it depends on the logs both of the CSP and of the CI/CD, it's limited to the retention of those logs. Some CI CI/CD products have very uh short default retention periods and also some organizations don't have very long retention times for their CSP logs. So any management event outside the intersection of the retention of those two log sources, this method won't work. But if it does exist, then this method uh just simply works. So this is our was our second contestant. And this method worked great for us because we could use it uh indiscriminatorily across a variety of different customer environments without needing to tailor uh it to every specific environment with uh specific products. Cool. So for our final contestant, we have the advanced code analysis. And in this method, we take all of the relevant files that are relevant to creation of identities, which are the code in your repos and your CI/CD configuration files. And we rely on this and finding all the identities being created in a specific environment through the state files. Once you have all the identities being created, you follow their names and feed everything to an LLM engine and hope that the LLM engine would be able to follow the process of the name templates as we've seen before and follow all the places and definitions where those variables are being defined. Find all those files and again allow us to trace back to the auditor editors of those files. We tried to uh kind of guide the LLM through those templates and give it uh the right uh uh prompts to do it but we couldn't find the right way. It was a very good solution and has a lot of potential but it has a lot had a lot of hallucinations and we didn't get the right linkage between files and the identity and we didn't have enough time to invest in it unfortunately. Um we do know that there was uh a talk yesterday about this. So uh maybe if we've seen it long enough before then we could have done better on this uh on this approach. And this leads us to concluding the uh showcase of all of the contestants and announcing the winner for us. And the winner for us at token security was the log based approach. And as Ali said, we needed to use it because we wanted to be agnostic to IA and to CSPs and we needed to not interact with the environments of our clients because we didn't want to be uh intrusive. So it was a great solution for us and this what worked for us but other solutions are very good as well for different use cases. For example, if you're using in your own organization, you can use the executionbased approach and tag your uh files in your IA deployments in order to have better monitoring of identities being created in your own organization because you don't have the problem of interacting with your own environment because the target environment is one that you control and own. So, it won't be a problem for you as it was for us. And of course the LLM approach which has a lot of potential and we didn't have enough time to invest in it unfortunately but we believe that it will probably be the best one especially when LLM is growing every day. So to sum up we just wanted to say that uh first of all and note the importance of uh ownership and the challenges we had to tackle with ownership was is not completely direct and goes through IEC and for non-human identities. Uh the second is that to show you the ways that we uh tackled and the um solutions that we find to tackle this challenge. And um of course a much more general note is that we needed to utilize more than one artifact and look at the bigger picture and understand that in order to uh find a solution to this complex challenge, we had to kind of get think outside of the box and found the right way and the right solution. Um, so we hope that you learned something new today and if not we hope that you enjoyed and thank you very much. Uh, thank you Dan and Iv. Uh, as always we will have questions in Slack for those who aren't here. If you're in the room and want to ask a question, uh, please raise your hand and, uh, we'll try to get to you. Uh, great question here. Um, hi, thank you for the presentation. Uh, I noticed you mentioned one of your main drawbacks um being log retention. Uh, do you just take that as like a risk uh risk acceptance um or how do you know down the line that your infrastructure is going to be um for instance tagged appropriately or do you take actions once you know you detect ownership? um or how do you verify that down the line you have infrastructure that doesn't have any kind of permanence as far as ownership on it um and then identifying so on a general note I would advise uh retention be as long as possible of course that there are uh trade-offs to that but I mean the best we can do when we approach a new environment is uh just improve the situation of retention from when we get there um but in general I would say that we just try to use uh in that in that perspective we try to use the maximum retention that we can get if it can be configured to be longer than uh we advise to do so. Uh and also I didn't mention it but there is one thing we can use to our advantage in terms of the CSP uh retention is that uh we can also use the creation event timestamps of identities that were created without the logs because the API actually returns that of when an identity was created. So that gives us uh even though it might be far back in time and it's a single event, it can give us very valuable information even if it's outside the retention period. But I I didn't really answer necessarily a question I think but that's kind of like the best way we can approach it in terms of uh um the effect we have on retention. Um, so one other question I just had quickly when you talk about tagging, you know, in my experience, one other team that cares very deeply about tagging is your finance team to make sure that they know who to attribute all the bills to. Have you thought about trying to find some partnership between finance and security to make sure um all the NHIS are tied because it's a very similar governance problem of making sure you define attacking schema appropriately, enforcing it, etc. Well, yeah, we we haven't thought about that. Um, but we did see that a lot of uh identities and resources in general are tagged and they're really come in handy for DevOps that do this. But it's a very interesting idea to cooperate with finance. So, I think this is kind of the same question, but why can't you just fail the build if they don't have an owner tag? Again, um enforce it in your pipeline that they must tag the resource with an owner with a specific owner. Yes. Uh so the problem is it's not always a single owner. uh as we said. So if you need to tag um like hardcode tag the owners for each one of the identities being created, it will be kind of messy because you don't always know who's going to be the owner for the identity. I I also want to add that I think that uh if you have full control over I mean if you're deploying it in your own organization I think that could be a good uh solution just like there are existing solutions of um like these databases where you store and log uh who the owners of identities are outside the platforms they exist in. However, what we've seen that when it's manually uh updated often it can be deprecated. Uh people can leave the company and it's not being updated. So that doesn't necessarily means it's accurate forcing it to be there. Hey, uh we had a question from the Slack. Uh is retention of logs no longer an issue if you're proactively building an identity to commit list or index? So for example, as you see CSP events, capturing the origin commit on an ongoing basis and just keeping those as soon as you start collecting this information from a certain point moving onward and I think it solves all the problems of retention indeed. But it only begins as soon as you start collecting all the required information and if you have all that then you're then you're all set. Thank you. Any other questions in the room? All right, let's give one final round of applause to Dan and Ilab.