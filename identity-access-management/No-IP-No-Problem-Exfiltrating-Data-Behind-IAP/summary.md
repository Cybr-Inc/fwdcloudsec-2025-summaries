# No IP, No Problem: Exfiltrating Data Behind IAP

**Video Link**: [Watch on YouTube](https://www.youtube.com/watch?v=g-XCNobgvaM)

- **Author**: Ariel Coleman (Mitiga)
- **Talk Type**: Security

## Summary

This presentation demonstrates a novel data exfiltration technique that exploits Google Cloud Platform's Identity-Aware Proxy (IAP) service through Cross-Origin Resource Sharing (CORS) mechanisms. The researcher shows how attackers can abuse the "Allow HTTP OPTIONS" setting in IAP to create a covert channel for exfiltrating sensitive data from secured environments, bypassing traditional network security controls.

## Key Points

- Identity-Aware Proxy acts as an identity firewall but contains risky configuration options
- Common misconfigurations include overly broad IAM grants and exposed bypass paths
- The "Allow HTTP OPTIONS" setting creates an exploitable data exfiltration channel
- Attackers can embed secrets in CORS headers and retrieve them externally without authentication
- Attack requires App Engine Deployer role and internal code execution capability
- Detection is possible through monitoring unusual deployment patterns
- GCP considers this expected behavior and has not changed the architecture

## Technical Details

**Identity-Aware Proxy Overview:**
- Acts as identity firewall intercepting requests to protected applications
- Blocks unauthenticated requests by default
- Handles authentication through Google Sign-In or configured identity providers
- Injects authentication headers into forwarded requests

**Common IAP Misconfigurations:**
1. **Overly Broad IAM Grants:**
   - "allUsers" member type allows any user globally
   - "allAuthenticatedUsers" allows any Google account holder
   - Both effectively disable IAP protection
   - Cloud Console shows warnings, but gcloud CLI does not

2. **Exposed Bypass Paths:**
   - Applications with multiple endpoints require IAP on each
   - Forgotten endpoints remain unprotected
   - Attackers can access same data through unprotected paths

**CORS and Preflight Mechanism:**
- Cross-Origin Resource Sharing prevents unauthorized cross-domain requests
- CORS preflight uses HTTP OPTIONS requests to check permissions
- Preflight requests are intentionally unauthenticated by design
- Server responds with "Access-Control-Allow-Origin" header indicating allowed origins
- Browser enforces access based on origin matching

**IAP Allow HTTP OPTIONS Setting:**
- Enables CORS functionality for applications behind IAP
- Allows unauthenticated HTTP OPTIONS requests to bypass IAP
- Necessary for web applications requiring cross-origin functionality
- Creates potential security vulnerability when misused

**Data Exfiltration Attack Chain:**

*Prerequisites:*
- Application protected by IAP with "Allow HTTP OPTIONS" enabled
- Internal attacker with code execution capability
- Attacker possesses App Engine Deployer role

*Attack Steps:*
1. **Internal Deployment**: Attacker deploys new application version with secret embedded in CORS header
2. **External Request**: External attacker sends unauthenticated HTTP OPTIONS request
3. **Data Retrieval**: Application responds with secret in Access-Control-Allow-Origin header

*Attack Characteristics:*
- No direct network communication between internal and external attackers
- Bypasses network firewalls and IAP authentication
- Can be automated for continuous data exfiltration
- Researcher achieved 15MB exfiltration per day through automation

**Technical Limitations:**
- Access-Control-Allow-Origin header limited to 8KB (protocol limitation)
- GCP-specific limit of 256 bytes per header
- Maximum 10,000 version deployments per day
- Deployment time (~20-25 seconds) limits burst exfiltration
- Can exfiltrate secrets, tokens, certificates, and encoded data

**Detection Methods:**
- Monitor "app engine create version" events in logs
- Look for unusual deployment frequency patterns
- Aggregate events by time windows (e.g., 10 deployments per 30 minutes)
- HTTP OPTIONS requests are not logged, making external activity undetectable

**Log Analysis:**
- Spike in deployment operations clearly visible in logs explorer
- Frequent version deployments (every 30 seconds) indicate suspicious activity
- Only internal deployment phase is logged; external retrieval is invisible

**Security Response:**
- Vulnerability disclosed to GCP
- GCP classified as expected behavior with low severity
- Documentation updated to highlight potential risks
- No architectural changes implemented by GCP
- Suggested domain validation for CORS headers was rejected

**Potential Secrets for Exfiltration:**
- Service account keys and tokens
- Database credentials and connection strings
- API keys and certificates
- Configuration files and secrets
- Any data that can be base64 encoded or converted to strings

**Mitigation Strategies:**
- Disable "Allow HTTP OPTIONS" if CORS functionality not required
- Implement strict monitoring of App Engine deployments
- Restrict App Engine Deployer role assignments
- Use least-privilege access principles
- Regular audit of IAP configurations and member grants

## Full Transcript

Good morning everyone. If you could go ahead and find your way to your seats, we'll be getting started here in just a moment. Um, this is the last talk of the morning session. Uh, but don't be sad. We have more talks after lunch as well as an entire day tomorrow. Um, just a couple housekeeping things to be aware of. Uh, did you order a shirt? Do you remember ordering a shirt? Uh, if not, definitely check the uh table where you got your badge. uh make sure that you pick up your shirt before you leave. Um in addition, I'd like to thank our sponsors who make this uh entire conference possible. Uh in particular, I'd like to thank uh Promeo who is a gold level sponsor. If you'd like to learn more about their products and services, you can find their booth in the vendor hall. Um if you have any questions at the end of this session, I'll be running around with a microphone, so feel free to save them. Uh joining us now is Ariel Coleman who is a senior security researcher and he's going to be giving the talk no IP no problem exfiltrating data behind IP. Please give him a warm welcome. Thank you. Thank you Nick. Hello everyone. Can you hear me? Yeah. Hello everyone. Welcome to my talk no IP no problem exfiltrating data behind IIP. I'm really excited to be here. So thank you for joining me today and I hope the talk going to be both insightful and interesting to you. So today's talk going to focus on one service in GCP called identity aware proxy. We'll explain what this service is, how it works and how attackers can abuse it to excfiltrate secrets from sensitive environments. So my name is Ariel Kalman. I'm security researcher at Mitiga and I came all the way from Tel Aviv, Israel and I'm a dog lover. So the agenda for today, we'll start by explaining what is identity aware proxy and how it works. I will show to you two misconfigurations that we saw in the wild too many times. Next, I'll do a quick intro to what is cross origin resource sharing a security feature in web browsers and explain how is it related to AIP. The last part will be the most interesting one and it will be um IP configuration that if enabled allow attackers to excfiltrate secrets from sensitive environments. So let's begin. What is identity aware proxy? Identityware proxy is a service in GCP that acts like an identity firewall. It sits in front of your application and it intercepts any request to that application. It control it controls the access to apps based on identity and when you use it it blocks any unauthenticated request to that application by default and it also has some interesting settings that we will show later. So how actually works when the user sends a request to the application the request hits the endpoint of the app and because IP is enabled to protect that endpoint the request is forwarded to IIP check if the request is authenticated or not and if the request is not authenticated he redirects the user to a Google signin page or to any identity provider that is configured in the environment the user needs to put his email and passwords and log to his account. Next, if the user was successfully logged in, he need to authorize to make sure he has sufficient role to access the app. If the user both authenticated and authorized, the request is forwarded to app to app engine in that case or any application with the headers of authentication injected to the request and the app engine can response to the user with the actual response to his request. From that moment the user can interact with the application without fill the IP in the middle without reauthenticate each time because he now has the token. So we understood what is AP and how it works. Let's dive into two misconfigurations that we saw in the wild. The first misconfiguration is overly broad IM grants. When you use AP to protect an application, you need to explicitly specify which users can access the app. And in GCP we have two special member types. The first is all users meaning every user in the world no matter if it's authenticated or not. And the second member type is all authenticated users meaning every authenticated user to a Google account no matter if that account is part of the organization or not. And adding one of these member types or two of them to the allowed users that can access the app effectively disabled IIP because now the user when he gets to the authorization party, he will just bypass it. So it shows how easy it is to make a mistake that effectively disabled IIP. This is how it looks in the platform. You can see me trying to add the all users member type to the allowed users that can access the app. When I do that action in the cloud console, I get a warning saying adding all users makes this resource public and accessible to anyone on the internet. However, when I do the exact same thing via the G-Cloud CLI, I get no warning and the operation just executed quickly. Okay. The second misconfiguration is exposing a bypass path around IP. As many of you know, many applications have multiple endpoints. And when you use IP to protect an application, you need to enable it for each endpoint. If the admin mistakenly forget one endpoint, IIP doesn't protect it. So it remain uh like attackers can sneak in through that endpoint. And this is how it looks. You can see the attacker that tries to access the application, but it has no token. So it blocked by the IP. However, when he sent the exact same request to the other endpoint of the same application, he get a response and he can access the same data. Okay, so we showed two misconfigurations. Now I want to do a deep dive into one risky setting that if enabled open the gate for attackers. The name of the setting is allow HTTP options and the description says control HTTP options course preflight. But to truly understand what this setting is, let's first of all understand what is course and what is co preflight. So course or gross original resource sharing when you search it online the first result that you see says it's something that designed to annoy developers. It works by giving you errors leaving you scratching your head. While it's sometimes true, let's demystify it a bit and explain how it really works. So what usually happens when a user access a web page is that he sends a request and gets back the response. HTML, JavaScript, CSS and images. Sometimes some of these resources are hosted on a different server on the internet. So to fetch these resources, JavaScript has a built-in function called fetch that fetches resources from a different server. It sends another request cross origin one to that server asking for that resource. But imagine what happen if instead of that legit JavaScript that tries to fetch an image, you get a malicious JavaScript code that tries to fetch sensitive information from the bank account server. You want to block this kind of attack. And this is why many browsers today have a built-in security feature called course. And course aims to prevents websites accessing other websites data without their permission. So when the bank server will get the request, he will check the origin of the request, the protocol, the domain and the port and he will decide if he wants to allow it to access that data or not. And if he wants to allow it to access the data, he will respond with a special header on the response called access control allow region. And keep in mind that header because it will be an integral part of the attack that we will show later. So the bank server respond with the access control allow region header in the response and he puts inside that header the origin that he wants to allow access to. The browser gets back the response and he will check if the origin that made the request is equal to the value in that response. If they are equal he allows us to access the response and if not he drops it. So this this is how this kind of attack can be prevented by course. But now let's take it one step further. Imagine that instead of this JavaScript that tries to fetch sensitive information from the bank server, you'll get a malicious JavaScript code that tries to send a post request to that server and execute a money operation, money transfer operation from account A to account B. because the bank server will get the request and do the operation before my browser will get back the response. My browser cannot uh block this kind of attack and this is why course have another layer of security called course preflight. So course preflight is a special type of HTTP options request that is sent by the browser before the re request. We basically ask the server is this request allowed like the original one that I wanted to send the post request that do the money transfer operation is this request allowed or not and then the bank server can respond with a yes or no if the bank server responded with a yes we allowed the real request to go through and be sent and if not my browser doesn't check doesn't send the real request to the server and one key note to know about this HTTP option request is that it's unauthenticated. This is by design. This process of communication between the user and the server supposed to be lightweight and simple. So these requests are unauthenticated and it cannot be changed. So we understood what is course and what is course preflight. Now let's get back to the setting to to explain what it means. The name of the setting again is allow HTTP options. So like we said before when you enabled IIP to protect an application it blocks any unauthenticated request by default and we also said that HTTP options request as part of this preflight process are unauthenticated. So it means that if the user sends an HTTP options request to the application, it blocked by the IP because the request is unauthenticated and this prevents applications behind IIP from working with course because this process is mandatory for applications to work. And this is why GCP added a setting that you can enable on IP that allow only HTTP options request to bypass AP without a token and reach to the application. And this is how it looks in the reality. You can see the user tries to send an HTTP options request simple one to the application but it blocked by the IP because he has no token. And this is what we expect from it to to happen. However, after we enabled the setting that allow HTTP options on AP, the user sent the exact same request to the application and get back the response. And if you can see in the response there is the specific header that we talked about the access control allow region and here the app engine put example.com which is the domain that he allows to access the sensitive information. But now let's let's think like an attacker. What happen if the attacker can control that response? What happen if the attacker can put a secret inside that response? So this will be the exact attack that we are about to show the excfiltration method. Before we begin explaining step by step how attackers can sneak data through that channel, let's explain the prerequisites and the diagram. The first prerequisite is that inside our environment that we want to excfiltrate secrets from, we have an application and we have an IP that protects that application and the setting to allow HTTP options is enabled on IP. The second prerequisite is that the attacker has some initial foothold inside the secret environment. It can be any form of code execution, a VM, cloud run, lambda function, anything that can execute commands. And the third prerequisites and the last one is that the internal attacker has the identity with the role app engine deployer which is a very common role that been given to developers where they need to publish the new de developed versions to the applications. So that's it. We want to excfiltrate a secrets from the internal attacker to the external attacker. This is our goal. But we can't just send a packet with a secret to the external attacker because we have a firewall inside that environment that blocks any outbound access or inbound access to that environment. We also cannot access from the external attacker to the internal environment because IP protects that application. The external attacker doesn't have any token. So every request is unauthenticated and um that's it. So let's explain step by step how the internal attacker can excfiltrate a secret to the external attacker. The first step is that the internal attacker deploys a new version to the application with a secret that he wants to excfiltrate. The deployment of the version is actually deployment of a YAML file that looks like this. multiple settings of the application where the internal attacker can put the secret that you want to excfiltrate inside that TML file in the access control allow region. Here I decided to put a shrug but it can be any uh encoded characters token certificate anything that can be encoded into characters. Okay. The second step is that the external attacker sends an HTTP options request to the application bypassing IIP because the setting that allow it is enabled and now the application got the request from the external attacker and this request is unauthenticated. This is a simple HTTP options request that can be happen from any VM in in the world if he knows the endpoint and the domain of the application that he wants to access to. And the third step of the attack is the response by the application to the external attacker. And inside the response, you can see the actual secret that we wanted to excfiltrate. And this is from the screen of the external attacker. And it shows that we were able to excfiltrate that secret from inside to the outside without sending a single packet from the internal attacker directly to the external attacker. Okay. So that's it. This is the attack. And this process can be automated to happen over and over to excfiltrate big files. The internal attacker deploys a new version with a new secret and the external attacker fetch it from the outside. Then the internal attacker deploys a new version with a new secret and the external attacker fetch it from the outside. And I was able to automate this process just out of curiosity to see how much data I can excfiltrate. And I was able to excfiltrate 15 megabytes of data during one day. And I know it doesn't sound like a much but it's enough for excfiltrating secrets, tokens, certificates, and anything that can be used later by the external attacker to uh expand the attack surface of the environment um and access more resources. Okay, so that was the attack. Now let's see how it looks in the logs when you do that. Here you can see a screenshot of the logs explorer in the uh GCP environment. You can see on the left a spike in the number of operations that happened during that time. And here you can see that the event app engine create version happened over and over. Every 30 seconds user zero deployed a new version. And this is a very weird activity. Like it's not something that's supposed to happen that a developer deploys a new version, sorry, a new version every 30 seconds. So this is why it's so easy to detect this kind of attack. This is the only detection you need to detect this attack. And this is al also the only detection you can write to detect this kind of attack because the only part that is logged is the first part where the uh internal attacker deploys the new version with the secret to the application. The HTTP options request is not logged anywhere. So the first step of the detection is filtering the relevant event which is app engine create version. The second step is just aggregating the events by some time window and count the number of events that happen during that time window. And the third step is filtering the threshold that you find relevant to your environment. In that case, I chose I chose 10 deploys per 30 minutes of window. Okay, that's it. Let's do a quick recap of what we showed today. We showed what is AIP, what is cross origin resource sharing and how they are related in that specific setting of AP. I showed to you also two IP misconfigurations that we saw in the wild. I showed to you how you can abuse AP setting to excfiltrate secrets. And lastly, I showed you how it looks in the logs and how you can detect it. That's it. Thank you for listening and I'm open to take any questions if you have. Thank you so much Ariel. Any questions in the room? Thank you. Um just curious to know if there is like any rate limiting settings on a saying like I don't allow you know more than um I don't know three consecutive option requests coming in. Yeah. So there is uh there is a limitation of the amount of characters that you can put inside the header of access control allow region which is 8 kilobyt. This is the limitation of the protocol not related to GCP uh limitation and there is a more specific limitation to GCP which is uh 256 bit per that header. We have another limitation which is the number of versions that you can deploy in one day which is 10,000. So it allows us to deploy many versions and excfiltrate big files. Uh but there is a limitation. So uh there is another limitation which is the amount of time that deployment of version takes. For example, it takes about I don't know 20 seconds, 25 seconds. So you can't do like a burst of deployments of versions and xfiltrate gigabytes of data. My limitation is 15 megabytes per day. This is the the best I could do. I thank you. Great research and talk. Really liked it. Um had this question. What kind of secrets can be embedded in the AML? Are there any default ones? What do you mean? Can you repeat? What kind of secrets can be embedded in the AML? Like what you showed was a random string? Yeah. But let's say I want to get a specific secret. Are there any default ones that you can get? So we assumed that the internal attacker have access to some secrets inside the environment that he wants to excfiltrate. Then he needs to encode it into B 64 or any other characters format and put it inside that header. And this is the only header that is visible from the external attacker. So the only thing you can do is put some kind of string inside that header and then exfiltrate it to the outside. Does GCP strip off uh headers that it would otherwise put in? So could you issue option headers and responses outbound without it being and let it be seen by an outside uh receiver? So we disclo this um issue to GCP and they said that this is expected behavior in some kind of way and they updated the documentation to highlight the risk of that uh abuse of that setting. But uh we offer them to change the logic and the way that they pass that header but they didn't want to change the architecture of the service because they thought the this attack is low impact and low severity. H so this is the only header that is visible in the outside and it remains like that until today. Um, shouldn't that header be an actual domain? Like a real domain? Like they could validate if it's an actual real Yeah, this is what I offer them to validate this is a real domain. But it's it's complicated, you know, to to like write a specific regax that catch every domain and doesn't have any false positive because this service is supposed to work and you can't like falsely write an REX that doesn't work. sometimes and prevent that value from being visible in the external attacker screen. So they decided that this is low severity and they keep it like that. That's all the time we have for questions. If you have any more definitely add them to the Slack thread. Uh can we get another round of applause for Ariel? Thank you.