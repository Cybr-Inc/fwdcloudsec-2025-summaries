# Securing Remote MCP Servers

**Video Link**: [Watch on YouTube](https://www.youtube.com/watch?v=9-e4VVPlWB8)

- **Author**: Jake Burkowski
- **Talk Type**: Security

## Summary

This talk examines security considerations for Model Context Protocol (MCP) servers, focusing on both local and remote deployments. Jake Burkowski, a Principal Architect at Snowflake, discusses how MCP represents a new API specification designed for LLM integration but introduces unique security challenges. The presentation covers transport layer security, authentication patterns, and recommends platform-level approaches for enterprise deployment rather than leaving security implementation to individual developers.

## Key Points

- MCP is a new API specification for LLM tool integration, but many implementations lack mature security practices
- Local MCP servers run as executables (via npx/uvx) while remote servers require transport layer security considerations
- Transport options include deprecated SSE (Server-Sent Events) and newer "streamable HTTP" which is essentially POST-based SSE
- MCP mandates OAuth for authentication but many implementations use URL-based tokens for simplicity
- The security model differs significantly from web browsers - instead of isolated websites with few extensions, MCP resembles "everything is a browser extension"
- Session management should use high-entropy session IDs bound to users and contexts
- Platform-level API gateway approaches are recommended over developer-implemented security
- Enterprise governance requires careful session isolation to prevent data commingling between tools
- Logging and monitoring are critical due to the non-deterministic nature of LLM interactions

## Technical Details

**Architecture Components:**
- Local MCP servers: Python/JavaScript executables run via npx/uvx
- Remote MCP servers: HTTP-based with SSE or streamable HTTP transport
- Client examples: ChatGPT, Claude Desktop, Cursor, Goose CLI
- Session management with server-assigned session IDs

**Transport Layer Security:**
- Server-Sent Events (SSE) - deprecated but still widely used
- Streamable HTTP - POST-based bidirectional communication
- DNS rebinding attack vulnerabilities require origin header validation
- CSRF protection needed when cookies are used for authentication

**Authentication/Authorization:**
- OAuth required by spec but often bypassed with URL tokens
- Confused deputy problems with third-party authorization servers
- Dynamic vs static client registration considerations
- Session binding to prevent hijacking

**Platform Recommendations:**
- Use API gateways (Cloudflare, Kong, F5, cloud provider solutions)
- Microsoft has Kubernetes-based MCP gateway
- FastMCP library versions (avoid deprecated 1.0, use 2.0+ or official Anthropic SDK)
- Implement session restrictions at middleware level

**Security Implementation:**
- Generate session tokens at platform level
- Unified logging across all MCP interactions
- Validate request URIs and OAuth codes
- Force re-consent for new clients
- Log context, tokens, user information, client/server details

---

## Full Transcript
I'm gonna introduce Jake uh with a talk titled securing remote MCP servers. Give it up for Jake. Um cool. Hi everybody. How are you? My name is Jake Burkowski. Um today we're going to talk a little bit about MCP servers. You may have uh read about them in headlines kind of like this. Um but first let's talk about me. Um, so I'm a principal architect and a field CTO at Snowflake. Primarily I build and talk about security and observability data links. Talk about data analytics. I talk about cool things you can do security, you know, security data. Um, it's a great role and a great team and we are hiring. I used to run delivery for a small cloud consultancy. Before that I was a cloud architect. Before that I was developer. Before that I delivered sushi. Uh, this talk however is about none of these things. It is especially not about Snowflake or security data lakes. And so all opinions are my own and do not represent that of my employer um or any sane person really. So now I do hope I can provide a little bit of entertainment for you, but the goal of this talk is not to blow anyone's mind. We're going to be a little bit more pragmatic here, right? A lot of the threat vectors from that previous side, things that got all the press, they're not really about MCP as a protocol. They're kind of just more what happens on the client side when you don't have proper tool isolation. Um, what we're going to talk about is everything on the server side, right? We're going to talk about MCP. It's still new. We're going to talk a bit about what it is. Um, but thankfully, what we're going to talk about today is closer to the threats, closer to the things that all of you or many of you already have comfortability with. So, uh, two goals of the session. First, we're going to inform about MCP server specific threats, right? concrete things that you should be doing differently uh for an MCP server rather than just an average server or for for a hosted exe. Second, we're going to clear up some confusion that's out there. Uh I think this standard it's evolving so fast that if you Google or you chat GPT it, you're actually going to automatically get outofdate information. Right? This talk, because I know this is being recorded, so I'm put a little time stamp on it. This is happening the last day of June in 2025. So if you're reading this in July of 2025, it's or listening to it, it's probably already out of date. Um, so and again, right, everything's going to be recorded, going to be put online. Um, and I'll probably also publish on my medium more of a reader friendly version. So, if you're again reading this or looking at this in the future, go go find my medium and maybe read along with it. So, uh, MCP. So, who and what is MCP? Um, MCP, it's a spec for writing APIs. Um, the the catch is that the documentation is built in so that an LLM has an easier time reading it, right? um MCP resources or servers they're generally either remote resources or they're local column executables right they get registered with clients so clients are things like chatgpt or claw desktop right cursor goose um basically think of MCP as an interoperable plug-in uh system so there's a bunch of other little experience features in there right you can call a tool you can call re list resources you can comes with default prompts completions Um, everyone's just adding features that they think are cool. Um, and that's good, right? Um, but again, not everything is implemented. Not every feature, first thing you want to know about it, is going to be implemented by every client, right? And not every client is going to be something that you automatically know about. It's not like a web browser. This is going to be a theme of this talk, by the way, where there's like two or three web browsers and you can probably block the ones you don't care about. Um, no, literally anything could be an MCP client. Um, and again, right, people I said they're making up new things, right? They're involving the spec. So, a lot of the things that people are making up are just newer versions of older things, but like, you know, a AI friendly, right? So, we're going to talk about streamable HTTP, which sounds like a solid, you know, stoic implementation. Um, but it's really just an implementation of SSE, which we'll also be talking about. Stands for service and events. Um, and that's just something that a HTT streamable HTTP that Anthropic just made up as its transport layer, right? right a couple weeks ago for MCP specifically right we're going to talk about backend OOTH proxying right now that's something that we've been doing we're trying to do for a while now right um the other day I read a proposal for for OATH on behalf of which is not MCP specific but someone wrote their own version for for agents right now these things aren't bad right it's not bad that we're say taking the existing things and we're saying well how do we make it different how do I make it different for AI right it's not bad but when a community wants to build it all themselves rather than use established kind of building blocks and specs either because they think they can do it better like the JavaScript community um or because they don't actually know those existing specs exist like the JavaScript community um you know it what it does is it introduces a trade-off right you're trading in flexibility right you're getting flexionality but you're going to lose stability you're going to introduce risk and that's going to introduce work for all of us security folk so for everyone here who charge by the hour. This is of course great news. Um, for the rest of us, right, a little bit of solace. The headlines that I shared before really more about the client side, right? Really more about what happens when these tools, you know, interact with each other. So, we're going to jump in here. The first thing I want to talk about um is actually not going to be the remote servers yet. It's going to be local servers, right? People talk about MCP servers. They can run in one of two ways. They can run on the same machine as the client. Think about it as some executable Python code or JavaScript usually. Or they can run remotely, right? Going across the the internet, right? We're going to talk about both of them. Both of these are MCP servers. I know the talk is about remote, so we'll focus a little bit heavier on remote. Um, but let's let's walk through it, right? So, we have this uh let's just say you're you're minding your own business and uh your favorite persistent insider threat or to use the politically correct term developer uh comes up and they ask you to deploy this MCP server. It works on their laptop. It's great. You need to deploy it now. We got to give it out to the company so that we can access right Slack from whatever tool we want to use. So, okay, great. What are the various ways that MCP servers can be hosted? What does that mean for your security? So number one, you're not actually hosting it, right? When it's local, you're really just hosting a file, right? The instructions for deployment are run via npx usually or uvx, which we'll talk about in a moment. Um, so think like you, you can know, you would run like a github.com/yyoureompmcpserver.py orjs. Um, if you can do that, that's great, right? Because now you're not you don't need to think about how to host an application. You don't need to think about the networking. Essentially, what you're going to do is you're just gonna, it's like hosting an executable or a library. And so, you're going to fall back on what you've already done and what you already know how to do, right? So, you want to scan the code. You want to make sure the dependencies are good. You want to make sure there's no secrets in the code, right? It's proprietary. Make sure your git repo is is is private, right? Use a build pipeline. All that wonderful apps stuff, all that wonderful developer security things. Um, useful tip number one, right? If you're running SAS and DAS, if you are scanning your code, right, run them periodically. Don't just run them before you deploy. Run them maybe even a little bit more often than you would regular write regular code, right? MCP, it's new. These servers and the tooling behind them is being developed a lot. They're very high visibility, right? These are things that didn't exist exist six months ago and now they're like all over the place, right? And a lot of times they're being built by startups, by hobbyists, right? So again, nothing wrong with that, but it means that maybe just because you scan something a week before you deployed, it doesn't mean it not new things haven't been found, right? So scan a little bit more frequently. Um, another thing, right, it's common to run local MCP servers in a container, right? It's up to the client and who how they're going to deploy it, but again, right, if you want to add that to your deployment instructions, might make things a little bit easier for you. I talked about npx and uvx, right? That's kind of like curlpipe to bash. So, npm, right? NPX just downloads from npm and runs something. UVX is the same thing using UV to download Python modules. Um, but here's the thing, right? A lot of these clients will run this command whenever they whenever they're booted up, right? So, that means that if you're hosting code, right? If you're hosting an MCP server that's a file and this is how it's commonly being deployed, right? That means that okay, maybe 9 in the morning everyone turns on their laptops, it's going to pull that file down. So a compromise of your repo can propagate a lot faster than say other code that you maintain. Right? Just things to be aware of. My advice takeaway from this slide is just ask first. If a developer says I need a I need an MCP server hosted, ask if they could go this approach. It is a little less complex than trying to do a remote server. So that's all done over over over standard standard IO. If it's remote, right, we'll start talking about transports. So we got a little bit of work to do here. I'm take a quick step back here and we'll talk about the transport layer. MCP is transport agnostic. I don't know why I wrote independent. Um but right they will define some common transports and these are what's going to be supported in libraries. These are going to be supported in in thirdparty MCP servers. It's technology called server send events SSE right that's good for streaming back responses. It's deprecated as of a few weeks ago but still obviously widely used. People are still making these things right. There's nothing wrong with this, by the way. Again, transport agnostic. But if a developer is giving you a version of something that has this in there, right? Especially if it's in a few months from when I make this talk, maybe check. Maybe that means that they're using an old version. Maybe it means that the dependencies they're using, the libraries have already been deprecated, right? Um, and again, right, for SSE, this isn't a talk on SSE security. Maybe look into it if you if you need to, but right, uh, MCP just works over get requests. So, just same thing with any get request. make sure that your off isn't using cookies. That could, right, open you up to curf attacks, you know, if the client's a web browser. Um, streamable HTTP, right? I already talked about this a little bit. Similar to SSE, but you're going to use post instead of get better birectional communication. You only need one point endpoint instead of two, right? With the norm with the old model, right? You would hit it and then an SSSE, right? Endpoint would then open up another connection. Um, this is vulnerable to DNS rebinding attacks as well. Also, same thing. Just make sure your server is checking the origin headers. Um, so this is where I rant for a little bit. Um, as if I haven't been doing that already. So, the thing about all of this, when you're reading about this, when people are talking about this, they're sounding familiar and everyone here is thinking about the browser, right? This is what we've been working on for like the last 20 years. And for people familiar with securing things, right? We want to think about things in terms of how we think about things in the web browser. But there's a few difference here, right? MCP is usually not running from a browser. It's running from a client. Claw desktop goose the CLI, right? Your IDE, right? Secondly, these paradigms, these isolation guarantees that we've come to expect from web browsers, they're completely turned on their head, right? So in a web browser, right, we have websites, they're completely isolated from each other, right? You know, you're you're logging into your bank here, you're looking at a meme on this site, right? they can't talk to each other, right? Um maybe you'll have a few browser extensions, but hopefully not too many. Um and you kind of know what they do, right? You have to click that button. This thing can view all my tabs, right? Well, in MCP land, and this isn't a problem with the protocol, this is just how things are implemented. It's kind of the opposite, right? We have like three websites, right? Chatgpt, Gemini, right? Ananthropic. Um, and then everything else you want to do has to install a browser extension. So imagine that, right? You want to check the weather extension here. You have your bank, you know, another extension. Everything can talk to each other. Um, so it's kind of again not a problem with MCP the same way that that wouldn't have been a problem with HTTP, problem with client implementation, right? So a lot of these attacks from the headlines um, essentially, right, they're going to be they're going to be mitigated by adding session isolation, but of course, right, complicated rules. I think you're going to be seeing a lot of this in the future. Complicated rule sets of which tool set can talk to which tool set and all of these fun things best implemented and mitigated on the client side. You may not have control over that. So we'll talk about some ways you can mitigate this on the server side as well, right? Um another thing, right? Uh the key takeaway from this slide is just forget about all the nice things your web browsers provide because we're kind of back to ActiveX with this one. I like that some people laughed at that. Um, so okay, authorization. Uh, there's a common misconception that there's no authorization in MCP. It's only half true, right? So MCP demands that you use OOTH forbids that you pass through tokens, right? Um, but a lot of implementations, they're just going to put the token in the URL, give you like what we call like a private endpoint. Um, people going to pass tokens around however they want. It's easier. Um, and OOTH is well oath is OOTH, right? Um, kind of a side note here is if anyone here wants to read, I do recommend reading the spec. It's like very readable, like human readable. Um, but when it comes to security, there's a lot of like musts in the spec, right? I think it's a little bit preun prefuncter. Um, they're getting better at it, but you will find things like server must be mindful of security or or logs must not contain credentials, right? Um, so just kind of keep that in mind. um you know when I when I see those that's why I'm here talking about this because I read the spec and I saw something that was to that effect like servers must be made secure by people and I'm like oh man they didn't think about security at all um but we are now um uh so and again right so same thing right you may not want to pass use ooth right don't just blindly pass on tokens it's going to make auditing harder auditing is hard enough as it is even without this system um right could open you up for some data exfiltration uh rate limiting will be harder to implement from an availability perspective. Um, and these are all more about remote MCP servers. Um, sessions, by the way, is the last one here. So, servers can assign a session ID, right? The client then must include it in subsequent requests, right? Use this for logging. Don't use these for O. Make sure your server actually drops requests that don't respect this. Bind everything, right? Bind the session to prevent session hijacking. Bind it to the user, right? Make sure you generate these session IDs with a lot of entropy, right? if there is a well-known trusted library for this that ever comes out and we're going to talk about um some ways to implement this on a platform level right do it there um and right a lot of uh a lot of popular implementations of MCP servers right will support forwarding to other MCP servers right so now you're going to think about okay how are we managing this in a gateway uh perspective all right uh this is oath um so if you are using oath a few more things to be aware of uh be mindful of the confused deputy your problem especially if you have any kind of third party authorization servers right if you can use dynamic client registration uh if you can't if you need a static client ID right things can get a little bit tricky right there's this you know there'll be this somewhere I think second or third line right you'll see there's this third party consent screen right if it's using cookies and remembering right the consent screen right that's going to open you up to a confused deputy a new client right which could be you know right you authorize it for the IDE but then you know some other fun MCP tool gets access to it, right? The user may not be aware of this, right? Again, right, keep track. You want to audit this. This is going to be the last slide, but audit, right? Keep track of which tokens are issued to which users, right? Log, bind, validate. Um, validate request URIs. Validate that the O code matches the session that was supposed to have requested it, right? Um, and then when in doubt, force reconent, right? Keep track of new clients. Once again, bind everything together. um thing about this right is it's all kind of hard to implement right and if you leave this up to the developers they're they're just going to vibe code you know write me an ooth implementation right so which is why I always recommend right let's let's use something that's already been written right we do this for everything right we don't we don't roll our own cryptography right we don't generally roll our own ooth right but here kind of there is that opportunity where it might accidentally happen so I think at this think at this stage taking a platform approach using API gateways uh is a good idea. Uh when I talk about enterprises that have been imp implementing this, been running this in production, um that seems to be the consensus, right? There are certain features that you can implement. I'm not a big fan of things like WFTS and whatever, but these tools are new, right? So, a couple of layers of additional security and alerting and monitoring they can they can help, right? Generate the I talked about those session tokens, right? generate them on the platform, have that authenticate and handle the downstream authentication, validate requests on this level, right? This kind of approach using some sort of a platform engineering approach. This will allow you that unified logging, right? Which is something you're going to want. We're going to talk about that on the next slide again. Right? Developers don't know how to Ooth. Oath professionals probably don't even know how to implement OOTH. It's tricky. It's subtle. It's easy to mess up. So, take that platform engineering approach, right? Build it once. once you have all the apps developing using it right you're going to be a little bit happier there um I actually kind of had an idea I haven't seen this in the wild but if anyone wants to try it and let me know how it works out um I kind of feel that when we are talking about session management right which tools wouldn't be that hard to write a little bit of middleware that just kind of restricts which unique tools could exist in a single session right this isn't just security this is governance right I I work for snowflake I have customers that don't want the data in the EU mixed with the data in the states Right? So implement that. Right? You may have two servers. You may want to give access to these tools to the same client, but you may not want that data comingling. Right? Add that session restriction on the server level as well as on the client level could help out a bit. That's just my idea. Again, may maybe I'll try building something and maybe that'll be my next talk. If anyone here ever wants to build it or has built it, do let me know. Um got about two minutes left. And so um takeaway again, right? I think until we have the clients that are as locked down as web browser, a lot of the enterprise governance is going to happen to happen on the platform level, right? Um, and then I'll just run through some of the solutions that already exist, right? There's this thing called fast MCP. There's two or actually technically three versions of this, which is why I put that meme in there. Um, we have fast MCP 1.0 that was then incorporated into the official anthropic maintained Python SDK, but remember that old code is still out there. Um, then we have 2.0, which I think is the same company. Um, and they kind of kept it and added enterprise features and all of this. I think it's kind of like one of those Ublock Ublock Origin things, but hopefully without the drama. Um, and then right at the minimum, I don't really have an opinion on what people should use, but just make sure that if you see fast MCP, make sure it's not that original 1.0 that's gotten merged in because that's definitely not supported. Um, and then write commercial players, right? Cloudfare has something API gateways. I had mentioned all the all the clouds have tutorials out there for how to do MCP behind their API gateways. Uh, a lot of people I talked to use Kong, right? This will support with their API AI gateway. F5 has their product. So, if you already have something, check, they probably support MCP by now. Um, and then there's like a million startups doing it. Open source gateways. Uh, if you're doing Kubernetes, uh, I haven't reviewed it, so it's not a recommendation, but Microsoft has this really cool MCP gateway that's handling a lot of the proxying to, uh, to Kubernetes. Um and then just to kind of wrap it up here, right, logging and monitoring, uh log everything, right? The nature of agentic people are going to tell you means like a lack of determinism. I don't know if I agree with that. I think human users already have a lack of determinism, but there could be a lot more edge cases, right? It's not an application that calls a rest pinpoint every single way, the same time, same time, every single way. But maybe an LLM decides that this time the parameter is going to be 5,000 characters long. um and unnecessary but maybe still valid, right? Observability is important, right? Things are changing fast. Make sure you're also get logging the context, right? You don't want you do want the tokens. You want what's going in, you want what's coming out. You also want information about the user, the context, log the client, log the server. Um and to wrap it up again, um couple of resources. We have the spec. We have GitHub. There's a really cool awesome MCP security repo by Mache Picowski. Um there's a Discord server, the MCP, it's an official MCP community working group as well as just follow me. I'm on LinkedIn, Medium is where I'll publish this one. Um and uh obviously the cloud cloud security forum. So thank you all very much. Any questions for Jake? Um I I couldn't quite remember when we're talking about authentication as it's implemented on MCP servers whether the goal is to generally do some kind of pass through or to literally not do a pass through. The question I have there is it's the authentication piece, right? Technically my MCP server has whatever service account to talk to the Atlassian API right my MCP Atlassian who's the actual actor and do I lose that when then I'll look at audit logs on Atlassian side it's so now you have to you know what is the Alassian M support right uh when I was talking about pass through I meant don't like generate like a regular API token and just say like okay I've authenticated to the MCP server and then you know have have it query vault or something and send the token back and say, "Okay, now you do what you want." Um, that's that's kind of was that advice about pass through. Um, yeah, but when it comes to thirdparty off servers, it's kind of on your own, right? Can you do a can you do on behalf of can you you know, you're going to need to configure the Atlassian MCP server or hope that they support the features that you want. Um, or maybe not. Maybe you don't need a backend, right? Maybe it's just, you know, authenticate and then we'll give you what you need. Hey, uh, great talk. I have kind of a two-part question around this. And one is that, um, you mentioned like authentication and authorization as being key concerns around this. Do you think that some of the other um, kind of API related security concerns are also really valid for MCPS? If you think about things like input validation and sanitization and those types of things. And then second is like because you're stripping away kind of the browser security model um and you kind of have this like weak session concept. I don't know if that's the right way to classify it but do you think that uh kind of like the APIs behind the MCP are more vulnerable to like kind of account takeover or like bola type attacks. So answer to the first question first question was should you secure the API in the way that you normally do? Uh, the answer I actually think is yes. Um, because it's an API. This is a 20-minute lightning talk, so I don't want to turn it into API security. But that's kind of other reasons why I recommend to just use the API gateway or really I don't even say use an API gateway. Use your platform approach, right? The things that you're doing now, you should continue to do answer the second question. Second question is, are the API services behind an MCP server more vulnerable? Um, from an infrastructure perspective, I don't believe so. I haven't seen it from uh you know otherwise maybe right when you think about all these attacks these rug poles and things I had put something in the description that we're going to talk about real world attacks if they happen they haven't yet so you know I'm I can only guess and I don't the answer is I don't know. All right everybody a round of applause for Jake. Thank you.