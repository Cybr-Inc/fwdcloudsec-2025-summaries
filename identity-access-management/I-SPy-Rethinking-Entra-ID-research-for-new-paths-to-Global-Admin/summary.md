# I SPy: Rethinking Entra ID research for new paths to Global Admin

**Video Link**: [Watch on YouTube](https://www.youtube.com/watch?v=oNpwtt1TEkQ)

- **Author**: Katie Nolles
- **Talk Type**: Cloud Security

## Summary

This talk explores the history and mechanics of service principal hijacking in Entra ID, building upon existing research to find new avenues for privilege escalation. The speaker, Katie Nolles, details her research journey of programmatically testing Microsoft's first-party applications for vulnerabilities, leading to the discovery of an attack path from the Application Administrator role to Global Admin by exploiting an inconsistency in how permissions are applied to service principals versus users. The attack involves hijacking the "Office 365 Exchange Online" service principal to create a federated domain backdoor, ultimately allowing the forging of SAML tokens to impersonate any synchronized user.

## Key Points

- Service principal hijacking has been a known attack vector since 2019, with Microsoft's stance evolving from "by design" to gradually implementing fixes.
- An Entra ID application is composed of two main objects: the App Registration (the template or definition) and the Service Principal (the local instance or identity).
- Credentials can be added to either the App Registration (affecting all tenants where the app is installed) or the Service Principal (affecting only the local tenant), creating different attack scenarios.
- The speaker discovered that the "Office 365 Exchange Online" service principal could still be backdoored with a certificate by an identity holding the Application Administrator role.
- This hijacked service principal possessed the `Domain.ReadWrite.All` permission, which was leveraged to execute a federated domain backdoor attack.
- The attack allowed forging SAML tokens for any synchronized user, including Global Admins, by adding a new trusted domain and certificate.
- A key finding was the inconsistency in permission enforcement: a *service principal* with the Application Admin role could perform the attack, but a *user* with the same role could not, an edge case MSRC declined to fix.
- For developers, enabling the `app instance property lock` on application registrations is a key mitigation to prevent this type of local credential addition to service principals.

## Technical Details

- **Roles Granting Attack Permissions**: `Application Administrator`, `Cloud Application Administrator`, or being an `owner` of a service principal allows adding credentials.
- **Microsoft Graph Permission**: `Application.ReadWrite.All` also grants the ability to add credentials to applications.
- **Attack Automation Steps**:
    1.  **Add Secret**: Attempted a `POST` request to the `addPassword` endpoint on all Microsoft first-party service principals.
    2.  **Add Certificate**: For apps that rejected secrets, a `PATCH` request was made to the service principal object directly to add a Base64 encoded certificate to the `keyCredentials` property. The `addKey` endpoint was not usable as it requires an existing certificate.
- **Authentication Flows**:
    - **With Secret**: Standard client credentials flow using the application ID and the generated secret.
    - **With Certificate**: A custom JWT had to be created, signed with the private key of the added certificate, and then exchanged for an access token from Entra ID.
- **Vulnerable Application Identified**: `Office 365 Exchange Online`.
- **Exploited Permission**: `Domain.ReadWrite.All`, which allows adding, verifying, and removing domains.
- **Federated Domain Backdoor Attack Chain**:
    1.  **Add Domain**: Use the token from the hijacked service principal to add a new, attacker-controlled domain to the Entra ID tenant.
    2.  **Verify Domain**: Add the provided DNS verification record to the attacker's DNS zone and request verification from Entra ID.
    3.  **Create Federation**: Configure the new domain for federation, adding an attacker-controlled certificate that will be trusted to issue SAML tokens.
    4.  **Target User**: Fetch the `on-premises immutable ID` (the Base64 encoded on-prem GUID) of a synchronized user to target (e.g., a Global Admin).
    5.  **Forge SAML Token**: Use a tool like `AADInternals` to create a SAML token. The token includes the target user's immutable ID, is signed by the trusted certificate, and can contain a claim to bypass MFA.
    6.  **Gain Access**: Exchange the forged SAML token with Microsoft's login services for a regular access token, successfully impersonating the target user with their full privileges.
- **Logging**: Actions performed during the domain federation part of the attack are logged as being performed by the hijacked service principal (e.g., `Office 365 Exchange Online`).
- **Inconsistency Discovered**: Only Global Admins are supposed to be able to assign credentials to the `Office 365 Exchange Online` service principal. However, a service principal with the `Application Administrator` role could bypass this restriction, whereas a user with the same role could not.

## Full Transcript

All right, welcome to track two. Please join me in welcoming to the stage Katie Nolles from Data Dog with her lightning talk I Spy rethinking Entra ID research for new paths to global admin. I would guess the SP has something to do with service principles. This talk is sponsored by Tracebit. Take it away Katie. Good morning. Thank you all for joining me. I know it was a fantastic night last night and I appreciate you waking up. Uh, welcome to I Spy Rethinking Intra ID Research and all the stuff Andrew said. A little about me. My name is Katie Nolles. I'm a cloud security researcher with Data Dog where I primarily focus on Azure security research. And around this time last year, I had just started in my research role. So, I was wondering what words of advice uh the fantastic Cloud Set community had for me on how to do my own projects. At which point uh Dan Gerlock provided the following fantastic advice. Now granted, he was dressed as a slice of noob cake to encourage us that research did not need to be intimidating, and he did say I could use this image of him again, and I figured I'd use his approach to structure some of my own projects this year. I had a different a couple different approaches and topics I wanted to learn about, but especially for getting some foundation uh on topics like Entra's application model, I really wanted to try and use this approach where you didn't necessarily need something new. You can build on what already exists. So today, we're going to talk about that journey. We're going to go over Entra ID's application model and how that relates to service principle hijacking. There's so much to go through, so I'm just going to jump in. We'll start out with the history of service principle hijacking and then we'll get into the details uh in a bit. But what you need to know is that this has been a thing since 2019. Uh Durkan MMA published a blog post about how Microsoft's first party applications could be used for privilege escalation and persistence. He originally reported this to MSRC and they said, "Oh yeah, we totally fixed that." And then he went and checked and they hadn't. So he then said, "Are are you sure?" And they said, "Oh, no, actually that's by design. Uh, you know, you you need to be able to assign a credential to the local identity of the app just for usability. Sometimes I don't know. Yeah, feel free to publish it." In 2020, uh, there was some thread actor activity, not directly related to first-party app, but general applications. We'll talk more about how that works in a sec, but what you need to know is thread actors were starting to pay attention. The Azure team also released their storm spotter tool which helped a little bit more with mapping permissions that service principles had uh to understand the risk that certain applications might impose. We had a talk at forward cloud from Amelia Chbuk and Christian Philippov highlighting the risk of service principles again uh and the fact that there were over 300 first-party apps in a default tenant. So there was a lot to choose from if you wanted to take over Microsoft applications. And sure enough, in 2022, thread actors started doing it too. You might think that uh this would have influenced the app instance property lock being added. And I'm not sure, but I think so. Basically, this setting made it so that if a developer flipped this switch on their application registration, you would no longer be able to add a credential to the local identities for that app. So it protected the local privesque scenario that we'll be talking about today. But Microsoft didn't seem to implement that for all of their applications. Uh as seen by some research last year from Eric Woodruff where he found further Microsoft firstparty apps where the that 300 plus we're talking about that shrunk. Uh but there were still a few that allowed privilege escalation to global admins sometimes with undocumented permissions. So we went from this being reported and Microsoft saying we don't think this is an issue to them saying you know we still don't think this is a material flaw. We don't see this as a problem but after all of this we can see how you might think it's a problem so we'll start to fix it. You might think based on everything we've talked about that this is just completely fixed. It's no longer an issue. Uh but when it was initially reported we also saw that they said it was fixed when it wasn't. Right. Are there any more gaps we can find here? I figured I'd test that out. Personally, this application model had been frustrating me for years, and this was a great excuse to dive in. With an entra ID, this is the background we'll need to go forward. Uh they, excuse me, an application is composed of two objects. One is the app registration and the other is the service principle. It's safe to think of the app registration as the definition of its app. Who made it, what it does, what permissions it needs in order to function. And the identity is what makes it go. It's the part that takes actions on that application's behalf. If I create a user management application and I decide to consume it, then I'll have a service principle and an app registration in my entra tenant. I created the app and I'm using the app. If you then decide you want to install that user management app in the same way to your environment, you'll then have a service principle added to your consuming tenant and be able to give it the same permissions that my application has uh in order to use it in your environment. Based on what we just said, you might think uh that the two are just completely linked. All their properties must be the same, right? We said definition and identity. But that is also not the case. Uh some properties are directly inherited. For example, the application ID links these two objects completely. Other properties are derived. So on the app registration, you can define what permissions an app needs to function, but then an administrator needs to consent to them to add them into that service principle. So an example would be here would be that the app role assignments or the application permissions. These are kind of used like a service account type permission. An app can use them without user interaction. And then the OOTH 2 permission grants or the delegated permissions that are granted to the app allow that app to take actions on behalf of a user. So that process of an admin or user consenting to different permissions will then add those into the identity, but they're not the same exact thing, right? Other properties have the same name, but they're totally different. Uh something that really shocked me about this is that key credentials and password credentials are properties that can be set in either place but they do not go back and forth at all. They don't synchronize in any way. So if a credential is assigned in either of those properties on either of those identities, you can become the application. Visually it looks a bit like this. If I'm the app owner and I add a credential to the app registration, so like a secret or a certificate, then I can authenticate as that application anywhere it's been installed, which should really make you think about how much you trust my user management app and me uh and any app that you add to your environment, right? On the other hand, if you want to use that application and kind of impersonate it in your local environment, I think this was added for debug purposes originally, you can add a credential to the local service principle, that local identity of the app, and you can also be that user management app within your environment if you have the right permissions. This is starting to sound a little attackery at this point, right? So, anybody with the application admin, cloud app admin, role or owner over an application will be able to add credentials in this way. The application readwrite all permission will also grant the same thing if you're using a uh like a compromised application. So in this illustration, we're seeing that an attacker with one of these roles in the publishing tenant can add a credential to that application and then be that application in any environment where the app was added. On the other hand, if they have the same permission in environment where the app was already added, the consuming tenant, they can still do some pretty interesting stuff, right? We're talking about a highly privileged app here. So if they can add a credential onto that, you might not suspect the app as much as uh you know attacker 123's account. So the where this gets extra hairy uh you can't see the credentials on service principles the way that you can for app registrations in the entra portal. So it's very sneaky. We're taking actions as applications not users. And this still includes some Microsoft firstparty applications that we can impersonate. What do I mean about first party? I keep saying that thing. What does it mean? And I want you to take a step back here and think about when you interact with the Azure portal. To you, it looks like you are using one web application. The reality is you're using an a complete mesh of services linked together by these applications we just talked about. Microsoft's first party apps are installed by default. You might have your own applications users use to create their own services. And you might install third party apps as well to provide service. So it's not as clean a web app uh as you might think it is. And this is where my adventure starts. I wanted to learn more about applications so I could give you the explanation you just heard. Uh and I also wanted to understand service principle hijacking a lot more in depth. I didn't have much time when I started this project. So I wanted to automate in little steps uh over the week, the weeks that I had. And I wanted to work directly with Microsoft Graphs APIs. The reason for this is that it's way easier to do a lot of this with PowerShell or the Azure CLI tools, but I wanted to understand the objects as closely as I could, as close to the bare metal, right? I wanted to see what was on them. I started out by trying to hijack all of Microsoft's service principles uh in my test tenant with a secret, which turned out to be a post request to the ad password endpoint on the service principle. All I needed to do was give a display name and it would say, "Okay, sure. Here's your secret. Now you can authenticate as that app locally." I thought that I could then take the app roll assignments off the same off the service principles endpoint uh properties, excuse me, to get uh all the app roles. This works for local apps but not Microsoft's first party applications. Unfortunately, those come back blank. They don't really populate uh when the applications are added to your environment. So, I was going to need some tokens. Now, I've added a secret. I need to test I can actually authenticate as that service principle by supplying the secret uh that I had just added that I wanted a graph token in the Microsoft login services along with the application ID using what's called the client credentials flow I would get back a JWT decoding that would lead to the roles that were assigned to that application so the Microsoft graph permission scopes basically you can also see in the WIDs parameter down there the entra ID roles that are assigned to that identity so you can See, uh, here we have the app admin. Just a good reminder, uh, that you can sometimes see a little bit more than you expect to in those gooids. I got a lot of errors back from this. The primary one that I saw was that secrets wouldn't work for this application and you should try a certificate instead. These other ones uh, basically just indicated that I didn't have permissions or the app was something I might not be able to add credentials to. Maybe it was legacy, something like that. So, I was going to need to add certificates. Right? At this point, I tried to add a secret to every application in my default tenant. Uh, I got a few that came back that said, "Hey, add a certificate instead." So, I thought that would be using the add key endpoint on the service principle. It turned out in order to use that, you need to prove you already had a certificate. Obviously, I'm not running around with certificates that allow me to authenticate as Microsoft firstp party apps. So, I kept reading and they actually said, "Don't worry about that. If you don't have a certificate to authenticate this app, just directly modify the service principle object, it's all good. So, this ended up being a patch request with a B 64 encoded that I wanted to use to authenticate. Getting tokens in this way turned out to be a little more complicated. Not bad once you figured it out. But we basically needed to attest that we had the certificate to authenticate as that application. So, I had to create my own JWT with a certificate thumbrint, various properties saying, "Hey, this is a valid token. I am the application. I have the certificate you trust to O as this app and then exchanged that token for one from Entra ID. That new token is the same one we were talking about before that decoded and had all those scopes we know and love. So here you can see an example of an application that I was still able to backdoor with a certificate for authentication. At this point we'll take a really quick look at how that looks. The script you're going to see me running just does all of the things that we talked about. Uh and it's a very dirty script, so you probably don't want it. The tokens that you see here are also long since expired, but we've got a token as a service principle with the cloud application administrator role assigned. We're going to use that token along with the certificate that we want to be trusted to author of that app and just the tenant ID as well. And once we run that, what it's going to do is add the certificate, generate that token that we're then going to exchange with Microsoft's authentication services to get a new token as the identity. When we decode that token we got back, we can see that we now have uh access as the Office 365 Exchange online application. So we can now take actions as this app. We can look like them in logging. Uh and we have access to all those interesting roles down below as well. Excuse me. It's what I get for making a slide like that. Uh, not all of the scopes that came back were interesting, but one in particular allowed me to add, verify, and remove domains, the domain rewrite all permission. This wasn't related to Microsoft graph attacks that I'd seen, but it made me think of another attack that I'd seen a while ago, and it led to some more adventures. In 2018, Dr. Ntori Cinema published support in Azure AD internals to add a federated domain backd dooror using the Azure Active Directory graph. Now, obviously, that's not the API we're using today. It's not the permissions we have, but you can take the same actions through that API. In 2020, attackers started doing this too. Uh, and Solar Winds, the Solar Winds attack, there were cases of sample tokens being forged using trusted certificates for these domains. I should mention these domains were originally set up to create uh, federated access with ADFS between that and Entra ID to trust the authentication there. I don't have time to talk about all of the different endpoints for this one, but I do have a demo to show you. Uh, so at this point I've got we've got that token as the Office 365 Exchange online service principle, right? We're going to use that to add an external tenant or excuse me an external domain that we've registered as the attacker 40th-cop.net which looks similar to the original tenant. Uh, but it's not. We will add that domain in and then get a DNS verification record just to verify that we own that domain which doesn't really matter to us. We're the attackers. We'll just slap it into our uh DNS records and then request that Entra ID verify that domain's been added. Once it's been added and we've verified we owned it, we can create a federation configuration. This is us adding another certificate that we want to be trusted to issue sample tokens for any synchronized users in the tenant. At this point, we should be able once it's added as the uh federated domain with our certificate. We don't actually need the domain at all. We can just use that certificate to create our own SL tokens as users we want to target. And we'll see that the actions here are logged as that service principle just showing that we have access to it. I'm not going to try to skip that. But after this, we'll see the actual targeting of a user. So every user that's synchronized within uh Entra Active Directory or Entra ID to Active Directory, I should say, has an immutable ID property. It's the B 64 encoded GID of their on-prem ID usually. And this links the two together. The words here are really small, but what you would see uh if you squint is that we're using that token as the application to fetch the on- premises immutable ID property of a user we want to target. In this in this case, a global admin. Once we have that property, that's the identifier we need to put in our SAML token. So, we're going to use uh AAD internals at this point to forge the SL token. We've got our the identity of a user we want to target, right, that we just fetched. We've got the certificate that's trusted to issue SL tokens on behalf of the tenant. And then we're going to say, you know what, why don't we bypass MFA too because MFA claims are trusted uh for this external domain we've added. This will then forge that sample token, provide it to the login services Microsoft has, and exchange it for a token that we can use in Entra as global admin. So, we've essentially gone from no accesses as global admin to attesting that we're global admin against Entra from a different system and then using that to navigate within Microsoft's web services. Because of the way that single signon is neatly built into this experience, we now have access to M365 uh Azure portal, all those good things. So, just to recap that from a diagram perspective, we added a domain that could be trusted. We added a certificate we wanted to be trusted and then we found the user's on premises ID that we wanted to target and used it to forge that sample token. We could then become really any synchronized user in the tenant. So anyone with an on- premises identity that's being synchronized into entra ID. At this point I thought I had a really cool finding on my hands. Right? We just went from application administrator to global admin using one of Microsoft's own applications. This is something they didn't seem as hot on anymore after recent research. Uh unfortunately they came back and pointed out something I should have seen from the start which is hey Katie cool tests but you were doing this all as a service principle. Can you do this as as a user with application admin? It's common to assign enter ID roles to users primarily though you might see it sometimes that it's assigned to a service principle. Um and sure enough when I tried to do this as a user I couldn't get it to work. In my mind, there wasn't any big difference between how an Entra ID role would be processed for an application identity versus a user. We're not talking about app permissions here. We're talking about entra roles. I was banging my head against a wall until Eric released some more research on this and mentioned that after some of the work he had done with MSRC, they mentioned that only global admins can assign credentials to that Office 365 Exchange online service principle. Now, so if I tested it with global admin in a user role, it worked. uh if I tested it with a service principle with app admin for some reason it worked but the user with app admin couldn't do it just a strange little glitch here uh so we clarified this finding with MSRC they unfortunately came back and said that due to the fact that this was assigned to a service principle they weren't really interested in fixing it it's a bit of an edge case but still a really fascinating finding for me at least and I hope the journey has taught you a bit about applications if you're interested in building your own research uh or doing your own research building off others I'd say take it patiently and how you think through the problem is the entire point of research. Right? We're trying to be as hyper specific about under what circumstances is something possible and in wording it that way. Does risk naturally fall out of it? Does it sound does this sound like something that should be happening the way it is? Uh definitely phone a friend if you get stuck. I've done that so many times on this research. And try not to get salty if people don't see the risk the way you see it. If you want to get started on service principle research, come find me and chat about these topics. They're all really cool. You've probably heard about some of them already uh yesterday or today. And aside from that, thank you so much for your time. All right, we have time for just a couple questions, maybe two, and then uh we got to change over the room all the way in the back here. Uh, thanks for the research. Um, as a Microsoft expert, I would call you Microsoft expert, do you think it's expected to escalate from app admin to global admin? Is that escalation path expected? And is there any mitigations possible that Microsoft could implement or end users could implement? Absolutely. Thank you for asking that. I think that question is the core of this talk. Right. The conversation around escalating from app admin uh to global admin has been a changing one. Microsoft's documents still attests that this is by design. Uh though it seems like they're doing things to fix it in the background, right? So hopefully that conversation continues to move that you shouldn't be able to do this. If you do have your own applications uh that you offer, setting that app instance property lock will prevent this kind of attack for anyone consuming your application. So I definitely recommend having that setting enabled. I think it's by default now, but it's always good to check. All right, one more question all the way in the front. Thank you. Great talk. So, has Microsoft restricted most uh first-party applications from this attack? Like only global administrators can now assign um uh credentials to to those. So, a couple of different points there. One is that for just those couple of I think it's the SharePoint and the Exchange ones, only global admin can assign creds. For the vast majority of Microsoft firstparty apps at this point, uh you can't assign creds to them locally at all. So I tried this against like 500 apps and the ones that you saw in that list were like the five that came back for my default tenant. Gotcha. Uh others may exist, but yeah, they've definitely gotten better. Okay, awesome. Thank you. Uh there'll be more details in the blog we'll be putting out in a couple weeks, too, for anyone curious. All right, we're going to wrap here, but uh before we do, what's one piece of advice you could give folks, Katie, that want to kind of poke at the boundaries around transitive trust like this? Like if they want to get started doing similar types of research? Yeah, I think uh understanding the boundaries of how things are defined in different systems is probably the core of it, but also if you don't think you're qualified, don't worry about that at all. Um thinking through it really hard and taking good notes is usually what I do. I don't identify as like a natural hacker type, but I still have a lot of fun. All right, give her one more hand. And thanks everybody for being here.
